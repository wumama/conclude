### JS数组深拷贝和浅拷贝那些事

在使用javascript对数组进行操作的时候，我们经常需要将数组进行备份，事实证明如果只是简单的将它赋值于其他变量，那么我们只要更改其中的任何一个，然后其他的也会跟着改变，这就导致了问题的发生。

#### push与concat的区别

push：像数组末尾添加一个或更多元素，并返回新的长度。该方法会改变数组的长度。

concat：连接两个或多个的数组，并返回结果，该方法不会改变现有数组，而仅仅会返回数组的一个副本。

```javascript
var a = [1,2]
a.push([3,4])
a.concat([5,6])
console.log(a)   //[1,2,[3,4]]
console.log(a.concat([5,6]))   //[1,2,[3,4],5,6]
```

#### 一、浅拷贝

javascript存储对象都是存地址的，所以浅复制会导致 a 和 b 指向同一块内存地址，数组的赋值其实相当于给了索引，改变其中一个变量其他引用都会改变。

```javascript
var a = [1,2,3]
var b = a
a[0] = 4
console.log(a)  //[4,2,3]
console.log(b)  //[4,2,3]
```

根据上面储存对象的问题，这里就可以解决一个问题：

原始参数（比如一具体的数字）作为值传递给函数；值被传递给函数，如果被调用函数改变了这个参数的值，这样的改变不会影响到全局或调用函数。

你传递一个对象（在JS里数组不是简单数据类型，而是对象）到一个函数，如果在函数里面改变了这个参数的内容，在外部这个变化是可见的。

####二、深拷贝

- slice()函数
- concat()函数

两个函数的原理都是返回数组的一个副本（相当于另外开辟内存空间），所以并不会改变数组本身的值。

```javascript
var a = [1,2,3,4,5]
var b = a.slice(0)  //slice()方法如果省略end值，那么方法将一直复制到数组的结尾
a[0] = 22
console.log(a)  //[22,2,3,4,5]
console.log(b)  //[1,2,3,4,5]
```

```javascript
var a = [1,2,3,4,5]
var b = a.concat()
a[1] = 'heihei'
console.log(a)  //[1,'heihei',3,4,5]
console.log(b)  //[1,2,3,4,5]
```

